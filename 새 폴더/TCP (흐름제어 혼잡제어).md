# TCP (흐름제어/혼잡제어)

- 신뢰적인 연결방식
- TCP는 기본적으로 reliable network를 보장할 수 있도록 하는 프로토콜
- network congestion avoidance algorithm을 사용

### 흐름제어

- 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법
- Flow Control은 receiver가 packet을 지나치게 많이 받지 않도록 조절
- receiver가 sender에게 현재 자신의 상태를 피드백한다.

### 흐름제어 해결 방법

- Stop and Wait : 매번 전송한 패킷에 대해 확인 응답을 받아야 그 다음 패킷을 전송

- Sliding Window : 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절

### 혼잡제어

- **송신측의 데이터 전달**과 **네트워크의 데이터 처리 속도** 차이를 해결하기 위한 기법

### 전송 과정

- 응용 계층에서 데이터를 전송할 때, 보내는 쪽의 애플리케이션은 소켓에 데이터를 쓴다.
- 이 데이터는 전송 계층으로 전달되서 세그먼트라는 작은 단위로 나누어진다.
- 전송 계층은 이 세그먼트를 네트워크 계층에 넘겨준다.
- 이때, 수신자는 수신 버퍼의 용량을 넘치게 하지 않도록 조절해야 한다.
- 수신자 쪽에서는 자신의 수신 버퍼의 남은 용량을 상대방에게 알려주는데, 이를 수신 윈도우라고 한다.
- 송신자는 수신자의 수신 윈도우를 확인하여 수신자의 수신 버퍼 용량을 초과하지 않도록 데이터를 전송한다.
- 이를 통해 데이터 전송중에 수신 버퍼가 넘치는 현상을 방지하고, 안정적인 데이터 전송을 보장한다. 이를 “**플로우 컨트롤**” 이라고 한다.

# **3 way handshake & 4 way handshake**

### 3 way handshake

- 양쪽 모두 데이타를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이타 전달이 시작하기전에 한쪽이 다른 쪽이 준비되었다는 것을 알수 있도록 한다.

### 과정

1. 클라이언트가 서버에세 SYN 패킷을 보낸다. 이 때 클라이언트는 SYN을 보내고 SYN/ACK 응답을 기다리는 SYN_SENT 상태가 된다.
2. 서버가 SYN(x)을 받고, 클라이언트로 받았다는 신호인 ACK와 SYN 패킷을 보내고 클라이언트가 다시 응답하기를 기다린다. 서버는 SYN_RECEIVED 상태가 된다.
3. 클라이언트는 ACK(x+1)와 SYN(y) 패킷을 받고, ACK(y+1) 을 서버로 보낸다. 서버의 상태는 ESTABLISHED가된다.

### 4 way handshake

- 연결을 종료하기 위해 수행되는 절차.

### 과정

- 클라이언트는 서버에게 연결을 종료한다는 FIN 플래그를 보낸다.
- 서버는 FIN을 받고, 확인했다는 ACK를 클라이언트에게 보낸다. (데이터를 보내기 위해 CLOSE_WAIT 상태가 된다.)
- 데이터를 모두 보냈다면, 연결이 종료되었다는 FIN 플래그를 클라이언트에게 보낸다.
- 클라이언트는 FIN을 받고, 확인했다는 ACK를 서버에게 보낸다. (아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT 상태에서 기다린다.)
- 서버는 ACK를 받은 이후 소켓을 닫는다.
- TIME_WAIT 시간이 끝나면 클라이언트도 닫는다.